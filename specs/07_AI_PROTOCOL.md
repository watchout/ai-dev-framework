# 07_AI_PROTOCOL.md - AI 中断・判断プロトコル

> **統合元**: 21_AI_ESCALATION.md
> **目的**: AIが不明点に遭遇した際の中断/続行判断と、Decision Backlog による進行管理を定義する

---

## 1. 基本原則

```
推測で進めるコスト:  手戻り = 数時間〜数日
即座に質問するコスト: 中断 = 1分

結論: 不明な点は即座に中断して質問する（ただし DETAIL層は例外 → §4参照）
```

---

## 2. 中断トリガー（T1-T7）

| ID | トリガー | 例 |
|----|---------|-----|
| T1 | SSOT に記載がない仕様判断 | 同時アップロード時の動作が未定義 |
| T2 | SSOT の記載が曖昧 | 「適切なエラーメッセージ」の定義が不明 |
| T3 | 技術的な選択肢が複数 | WebSocket vs SSE vs ポーリング |
| T4 | SSOT と既存実装の矛盾 | SSOT=論理削除 vs 既存=物理削除 |
| T5 | 制約・規約に未定義のケース | Service→ExternalAPI の位置づけ未定義 |
| T6 | 影響範囲が不明 | DBスキーマ変更の波及先が不明 |
| T7 | ビジネス判断が必要 | 無料プラン超過時: ブロック or 警告続行 |

---

## 3. 中断時の行動プロトコル

### 3.1 中断通知フォーマット

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[!] 作業を中断します（確認が必要です）

トリガー: [T1-T7]
発生箇所: [何をしている時に発生したか]

質問:
[具体的な質問]

選択肢（あれば）:
a) [選択肢A] → [影響]
b) [選択肢B] → [影響]

推奨: [推奨案]（根拠: [理由]）
影響範囲: [この決定が影響する他の機能・ドキュメント]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

### 3.2 回答後のフロー

```
ユーザー回答
  │
  ├── SSOTの変更が必要? → No → 実装に反映 → 作業再開
  │
  └── Yes → SSOT更新案を作成 → ユーザー確認 → SSOT更新 → 作業再開
```

SSOT更新時は §1 変更履歴に記録する:

```
| バージョン | 日付 | 変更内容 | 理由 | 変更者 |
|-----------|------|---------|------|-------|
| 1.1 | YYYY-MM-DD | §7 BR-012 追加 | T1トリガーで発覚 | AI + ユーザー |
```

### 3.3 質問の品質基準

```
必須要素:
  - 何について聞いているか明確
  - なぜ聞く必要があるか（トリガーID）を明示
  - 選択肢を提示（可能な場合）
  - 推奨案と根拠を提示
  - この決定の影響範囲を明示
```

---

## 4. 止まるか進むか: SSOT層別判定マトリクス

### 4.1 判定フロー

```
不明点を発見
  │
  ├── T4（矛盾）or T6（影響範囲不明）? → 常に停止
  │
  ├── CORE層 or CONTRACT層? → 停止して質問（T1-T7）
  │
  ├── DETAIL層?
  │   ├── 影響が大きい? → Feature Flag で隠して進む
  │   └── 影響が小さい? → デフォルト案で進む
  │   └── いずれも Decision Backlog に記録
  │
  └── 判断できない → 停止して質問
```

### 4.2 整合性マトリクス

| トリガー | CORE/CONTRACT | DETAIL | 備考 |
|---------|:------------:|:------:|------|
| T1: SSOT未記載 | 停止 | 進む | DETAIL はデフォルト案で |
| T2: SSOT曖昧 | 停止 | 進む | DETAIL はデフォルト案で |
| T3: 技術選択肢複数 | 停止 | 進む | 後から変更可能なら進む |
| T4: SSOT/実装矛盾 | **常に停止** | **常に停止** | 層を問わず |
| T5: 規約未定義 | 停止 | 進む | 安全側のデフォルトで |
| T6: 影響範囲不明 | **常に停止** | **常に停止** | 層を問わず |
| T7: ビジネス判断 | 停止 | 進む | Feature Flag で切替可能なら進む |

### 4.3 DETAIL層で進んでよい項目

```
- エラーメッセージの文言 → デフォルト文言で実装
- バリデーションの閾値 → 合理的なデフォルトで実装
- UI文言・ラベル → 仮文言で実装
- 性能目標の具体値 → 一般的な目標値で実装
- 例外ケースの詳細動作 → 安全側に倒して実装
- UI上の表示順・並び順 → デフォルト（新しい順）で実装
- 無料/有料の境界 → Feature Flag で切り替え可能に実装
```

### 4.4 CORE/CONTRACT層で停止すべき項目

```
- 機能の目的・スコープが不明
- ビジネスルールの根幹が不明
- 権限モデルが未定義
- APIの入出力型が未確定
- DBの主要テーブル構造が不明
- 画面遷移の根幹が不明
```

---

## 5. 進む場合の行動プロトコル

```
Step 1: デフォルト案を選定
  - 安全側に倒す（セキュリティ > 利便性）
  - シンプルな方を選ぶ
  - 後から変更しやすい方を選ぶ

Step 2: Decision Backlog に記録（→ §6 参照）

Step 3: コードにマーカーを付与
  // DECISION: DB-001 - デフォルト案Aで実装。決定後に変更の可能性あり
  const MAX_RETRY = 3; // DB-001: 要確認

Step 4: 影響が大きい場合は Feature Flag
  if (featureFlags.isEnabled('DB-001-optionA')) { ... }

Step 5: セッション終了時にユーザーへ報告
  「以下の未決定項目をデフォルト案で実装しました:
   DB-001: エラーリトライ回数 → デフォルト: 3回
   DB-002: セッション有効期限 → デフォルト: 24時間
   Decision Backlog に記録済みです。確認・決定をお願いします。」
```

---

## 6. Decision Backlog フォーマット

保存先: `docs/ssot/DECISION_BACKLOG.md`

```markdown
# Decision Backlog

## 未決定

### DB-001: エラーリトライ回数
- 発見日: YYYY-MM-DD
- トリガー: T1（SSOT未記載）
- SSOT層: DETAIL
- デフォルト案: 3回（一般的なデフォルト値）
- 他の選択肢: a) 5回（耐障害性重視） b) 1回（即時失敗）
- 副作用: リトライ回数が多いとレスポンス遅延の可能性
- 決定期限: Sprint N 終了まで
- コードマーカー: `// DECISION: DB-001`
- 関連ファイル: src/lib/api-client.ts:42

## 決定済み

### DB-000: セッション有効期限
- 決定日: YYYY-MM-DD
- 決定: 24時間
- 理由: ユーザーヒアリングの結果
- 反映: SSOT §7 に追記済み、コードマーカー削除済み
```

---

## 7. フェーズ別の中断チェックポイント

### 実装時

| 状況 | トリガー | 例 |
|------|---------|-----|
| ビジネスルールのカバー漏れ | T1 | 空文字入力時の動作が未定義 |
| 技術アプローチが複数 | T3 | 同期 vs 非同期（UIブロック 3秒 vs 複雑度増） |
| 既存コードとの矛盾 | T4 | SSOT=UTC保存 vs 既存=JST保存 |

### 修正時

| 状況 | トリガー | 例 |
|------|---------|-----|
| 影響範囲が判断できない | T6 | APIレスポンス型変更 → フロント影響 |
| 修正がSSOT変更を必要とする | T4 | バグ修正で BR-005 を変更する必要 |

### テスト時

| 状況 | トリガー | 例 |
|------|---------|-----|
| 未定義エッジケース発見 | T1 | SSOTにないテストケースを発見 |
| SSOT vs 実装の不一致 | T4 | テスト失敗: どちらが正か不明 |

---

## 8. 禁止行動

```
- 「おそらく○○だろう」と推測して実装する
- 「一般的には○○なので」と CORE/CONTRACT 層のデフォルトを勝手に選ぶ
- 「後で確認する」として仮実装で進める（DETAIL層を除く）
- TODO/FIXME で CORE/CONTRACT 層の不明点を後回しにする
- SSOTにない仕様を「良かれと思って」追加する
- エラーケースが不明だから握りつぶす
- 複数回の質問を避けるために曖昧なまま進める
```

---

## 9. 自己進化型ルール（再帰的学習）

### ルール追記トリガー

| ID | 条件 | 例 |
|----|------|-----|
| R1 | 同じ種類のバグを2回修正 | any型バグ → 「any禁止、unknown + 型ガード」 |
| R2 | 同じ監査減点が2回発生 | console.log残存 → 「実装完了時に全削除」 |
| R3 | 同じレビュー指摘2回 | エラーハンドリング漏れ → 「API呼び出しに必ず try-catch」 |
| R4 | テスト失敗パターン再発 | await忘れ → 「非同期関数に必ず await」 |
| R5 | 質問の回答が汎用ルール化可能 | 「日時は全てUTC」→ ルール化 |

### 追記フォーマット（CLAUDE.md 内）

```markdown
## 学習済みルール（自動追記）

### [YYYY-MM-DD] [カテゴリ]
- ルール: [具体的なルール]
- 根拠: [なぜこのルールが必要か]
- 発生元: [どのタスク/監査で判明したか]
```

### 追記プロトコル

```
1. ルール追記案を作成
2. ユーザーに提示して確認（「以下のルールを追記してよいですか？」）
3. 承認後に CLAUDE.md に追記
4. 既存コードに同じ問題がないかスキャン
```

禁止: ユーザー確認なしの変更、1回限りの特殊ケースのルール化、既存ルールとの矛盾

---

## 10. Memory Persistence

### 保存先と構造

```
.claude/memory/
├── session_state.json   ← タスク状態（Phase, Step, ブロッカー）
├── decisions.md         ← 意思決定ログ
├── patterns.json        ← 学習パターン
└── open_issues.md       ← 未解決の問題
```

### セッション開始時

```
1. .claude/memory/ の存在を確認（なければ初回セッション）
2. session_state.json → 前回のタスク状態を復元
3. decisions.md → 直近5件の意思決定を把握
4. open_issues.md → 未解決の問題をユーザーに報告
5. 状態サマリーを表示して続行/切替を確認
```

### セッション終了時

```
1. タスク状態を session_state.json に書き出し
2. 意思決定を decisions.md に追記
3. パターンを patterns.json に追記
4. 未解決の問題を open_issues.md に追記
```

---

## 11. Strategic Compact（コンテキスト管理）

### 情報の優先順位

| Priority | 扱い | 内容 |
|----------|------|------|
| P1: 絶対保持 | そのまま保持 | CLAUDE.md ルール、現在タスクのSSOT、認証状態、エラーコード、T1-T7 |
| P2: 要約保持 | 要約に変換 | 関連SSOT要約、直近5件の意思決定、テスト結果サマリー |
| P3: 退避 | .claude/memory/ に保存 | 他機能のSSOT、過去の意思決定、完了済みタスク詳細 |
| P4: 破棄可 | 破棄 | 中間出力、試行錯誤の履歴、修正前コード、デバッグ出力 |

### コンパクション提案タイミング

```
CT1: 長いデバッグセッション後（中間の試行錯誤を破棄）
CT2: 大ファイル読み込み後（要約に切替）
CT3: タスク切替時（前タスクの詳細を退避）
CT4: セッション長時間経過時（コンテキスト使用量が高い場合）
```

---

## 変更履歴

| 日付 | 変更内容 |
|------|---------|
| - | 21_AI_ESCALATION.md から統合・圧縮して作成 |
